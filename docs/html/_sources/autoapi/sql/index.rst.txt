sql
===

.. py:module:: sql

.. autoapi-nested-parse::

   Provide tokenizer and parser to generate an SQL AST and a cross-compiler for
   the Notion API.

   Central module providing SQL parsing as well as cross-compiling SQL-to-JSON capabilities.
   To generate ``INSERT`` constructs, the cross-compiler needs a repository where all
   the table metada are stored and accessible.

   Example usage for the :class:`Parser`:
       >>> # create an AST for a supported SQL construct
       >>> sql = "create table students (id int, name title_varchar(255), grade varchar(1))"
       >>> parser = Parser(tokenize(sql))
       >>> ast = parser.parse()

       >>> assert isinstance(ast, CreateTable)
       >>> assert ast.table_name == 'students'

   Example usage of the cross-compiler :class:`SqlToJsonVisitor`:
       >>> # cross-compile create table
       >>> sql = "create table students (id int, name varchar(255), grade varchar(1))"
       >>> ast = Parser(tokenize(sql)).parse()
       >>> visitor = SqlToJsonVisitor()
       >>> output = visitor.visit(ast)
       >>> print(output)

       >>> # cross-compine insert into
       >>> # Create the table and add it to the table catalog
       >>> sql = "create table students (id int, name varchar(255), grade varchar(1))"
       >>> students_table = Parser(tokenize(sql)).parse()
       >>> table_catalog: MetaData = MetaData()
       >>> table_catalog.add(students_table)
       >>> # Create the insert statement
       >>> sql = "insert into students (id, name, grade) values (1, 'Isaac Newton', 'B')"
       >>> ast = Parser(tokenize(sql)).parse()
       >>> visitor = SqlToJsonVisitor(table_catalog)
       >>> output = visitor.visit(ast)
       >>> print(output)



Attributes
----------

.. autoapisummary::

   sql.Token
   sql.KEYWORDS
   sql.TOKEN_REGEX


Classes
-------

.. autoapisummary::

   sql.TokenType
   sql.SqlNode
   sql.Visitor
   sql.MetaData
   sql.ColumnDef
   sql.CreateTable
   sql.InsertStatement
   sql.Parser
   sql.SqlToJsonVisitor


Functions
---------

.. autoapisummary::

   sql.tokenize


Module Contents
---------------

.. py:class:: TokenType(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Enum for token types used in the tokenization.


   .. py:attribute:: KEYWORD


   .. py:attribute:: IDENTIFIER


   .. py:attribute:: SYMBOL


   .. py:attribute:: NUMBER


   .. py:attribute:: STRING


   .. py:attribute:: EOF


.. py:data:: Token

   Type alias for a token used by :func:`tokenizer()`.

.. py:data:: KEYWORDS

   Dictionary defining all the supported SQL keywords.

.. py:data:: TOKEN_REGEX

   Regular expression representing a single SQL token.

.. py:function:: tokenize(sql: str) -> Iterator[Token]

   Provide a :type:`Token` iterator from the supplied SQL construct.

   :param sql: The SQL construct to be tokenized
   :type sql: str

   :raises SyntaxError: Unexpected charachter at position index.

   :Yields: *Iterator[Token]* -- The :type:`Token` iterator


.. py:class:: SqlNode

   Bases: :py:obj:`abc.ABC`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: _operation


   .. py:property:: operation
      :type: dict



   .. py:method:: accept(visitor: Visitor) -> dict
      :abstractmethod:



   .. py:method:: compile() -> None
      :abstractmethod:


      Compile the node to an executable JSON object.

      Subclasses use this method to create the dictionary representing the operation as the following
      example shows for the SQL statement ``CREATE TABLE``::
          {
              "endpoint": "databases",
              "request": "create",
              'payload": {
                  "title": [
                      {
                          "type": "text",
                          "text": {"content": "students"}
                      }
                  ],
                  "properties": {
                      "studentid": {"number": {}},
                      "name": {"title": {}},
                      "grade": {"rich_text": {}}
                  }
                  # TODO: add "parent" object
              }
          }



.. py:class:: Visitor(table_catalog: Optional[MetaData] = None)

   .. py:attribute:: _table_catalog
      :value: None



   .. py:method:: visit(node: SqlNode) -> dict


   .. py:method:: visit_ColumnDef(node: ColumnDef) -> dict
      :abstractmethod:



   .. py:method:: visit_CreateTable(node: CreateTable) -> dict
      :abstractmethod:



   .. py:method:: visit_InsertStatement(node: InsertStatement) -> dict
      :abstractmethod:



.. py:class:: MetaData

   Provide a repository to store table metadata.

   This class represents a table catalog where all table-related metadata are stored.
   It provides a dictionary-like interface to check existence and access stored metadata.


   .. py:attribute:: tables
      :type:  Dict[str, CreateTable]


   .. py:method:: add(table: CreateTable) -> None


   .. py:method:: __contains__(table_ident: Union[CreateTable, str]) -> bool


   .. py:method:: __getitem__(tablename: str) -> CreateTable


.. py:class:: ColumnDef(name: str, type: str)

   Bases: :py:obj:`SqlNode`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: name


   .. py:attribute:: type


   .. py:method:: compile() -> None

      Compile the node to an executable JSON object.

      Subclasses use this method to create the dictionary representing the operation as the following
      example shows for the SQL statement ``CREATE TABLE``::
          {
              "endpoint": "databases",
              "request": "create",
              'payload": {
                  "title": [
                      {
                          "type": "text",
                          "text": {"content": "students"}
                      }
                  ],
                  "properties": {
                      "studentid": {"number": {}},
                      "name": {"title": {}},
                      "grade": {"rich_text": {}}
                  }
                  # TODO: add "parent" object
              }
          }



   .. py:method:: __eq__(value: SqlNode) -> bool


   .. py:method:: __repr__() -> str


   .. py:method:: accept(visitor) -> dict


.. py:class:: CreateTable(table_name: str, columns: List[ColumnDef])

   Bases: :py:obj:`SqlNode`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: table_name


   .. py:attribute:: columns


   .. py:method:: compile()

      Compile the node to an executable JSON object.

      Subclasses use this method to create the dictionary representing the operation as the following
      example shows for the SQL statement ``CREATE TABLE``::
          {
              "endpoint": "databases",
              "request": "create",
              'payload": {
                  "title": [
                      {
                          "type": "text",
                          "text": {"content": "students"}
                      }
                  ],
                  "properties": {
                      "studentid": {"number": {}},
                      "name": {"title": {}},
                      "grade": {"rich_text": {}}
                  }
                  # TODO: add "parent" object
              }
          }



   .. py:method:: accept(visitor: Visitor) -> dict


.. py:class:: InsertStatement(table_name: str, columns: List[str], values: List[Union[int, str]])

   Bases: :py:obj:`SqlNode`


   Helper class that provides a standard way to create an ABC using
   inheritance.


   .. py:attribute:: table_name


   .. py:attribute:: columns


   .. py:attribute:: values


   .. py:method:: accept(visitor) -> dict


.. py:class:: Parser(tokens: Iterator[Token])

   Create an SQL AST for a given SQL construct.

   .. attribute:: `tokens`

      The `Token` iterator.

   .. attribute:: `current`

      The current `Token`.


   .. py:attribute:: tokens


   .. py:attribute:: current


   .. py:method:: eat(expected_type, expected_value=None)


   .. py:method:: parse()


   .. py:method:: parse_create_table() -> CreateTable


   .. py:method:: parse_insert() -> InsertStatement


.. py:class:: SqlToJsonVisitor(table_catalog=None)

   Bases: :py:obj:`Visitor`


   .. py:method:: visit_CreateTable(node: CreateTable) -> dict


   .. py:method:: visit_ColumnDef(node: ColumnDef) -> dict


   .. py:method:: visit_InsertStatement(node: InsertStatement) -> dict


