sql
===

.. py:module:: sql

.. autoapi-nested-parse::

   Provide tokenizer and parser to generate an SQL AST and a cross-compiler for
   the Notion API.

   Central module providing SQL parsing as well as cross-compiling SQL-to-JSON capabilities.
   To generate ``INSERT`` constructs, the cross-compiler needs a repository where all
   the table metada are stored and accessible.

   Example usage for the :class:`Parser`:
       >>> # create an AST for a supported SQL construct
       >>> sql = "create table students (id int, name title_varchar(255), grade varchar(1))"
       >>> parser = Parser(tokenize(sql))
       >>> ast = parser.parse()

       >>> assert isinstance(ast, CreateTable)
       >>> assert ast.table_name == 'students'

   Example usage of the cross-compiler :class:`SqlToJsonVisitor`:
       >>> # cross-compile create table
       >>> sql = "create table students (id int, name varchar(255), grade varchar(1))"
       >>> ast = Parser(tokenize(sql)).parse()
       >>> visitor = SqlToJsonVisitor()
       >>> output = visitor.visit(ast)
       >>> print(output)

       >>> # cross-compine insert into
       >>> # Create the table and add it to the table catalog
       >>> sql = "create table students (id int, name varchar(255), grade varchar(1))"
       >>> students_table = Parser(tokenize(sql)).parse()
       >>> table_catalog: MetaData = MetaData()
       >>> table_catalog.add(students_table)
       >>> # Create the insert statement
       >>> sql = "insert into students (id, name, grade) values (1, 'Isaac Newton', 'B')"
       >>> ast = Parser(tokenize(sql)).parse()
       >>> visitor = SqlToJsonVisitor(table_catalog)
       >>> output = visitor.visit(ast)
       >>> print(output)



Attributes
----------

.. autoapisummary::

   sql.Token
   sql.KEYWORDS
   sql.TOKEN_REGEX


Classes
-------

.. autoapisummary::

   sql.TokenType
   sql.SqlNode
   sql.Visitor
   sql.MetaData
   sql.ColumnDef
   sql.CreateTable
   sql.InsertStatement
   sql.Parser
   sql.SqlToJsonVisitor


Functions
---------

.. autoapisummary::

   sql.tokenize
   sql.text


Module Contents
---------------

.. py:class:: TokenType(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Enum for token types used in the tokenization.


   .. py:attribute:: KEYWORD


   .. py:attribute:: IDENTIFIER


   .. py:attribute:: SYMBOL


   .. py:attribute:: NUMBER


   .. py:attribute:: STRING


   .. py:attribute:: EOF


.. py:data:: Token

   Type alias for a token used by :func:`tokenize()`.

.. py:data:: KEYWORDS

   Dictionary defining all the supported SQL keywords.

.. py:data:: TOKEN_REGEX

   Regular expression representing a single SQL token.

.. py:function:: tokenize(sql: str) -> Iterator[Token]

   Provide a :class:`Token` iterator from the supplied SQL construct.

   :param sql: The SQL construct to be tokenized
   :type sql: str

   :raises SyntaxError: Unexpected charachter at position index.

   :Yields: *Iterator[Token]* -- The :class:`Token` iterator


.. py:class:: SqlNode

   Bases: :py:obj:`abc.ABC`


   Base class for an AST node.


   .. py:attribute:: _operation

      The compiled operation as dictionary.


   .. py:property:: operation
      :type: dict


      Provide the compiled operation.

      This read-only attribute holds the result of the compilation.
      It delivers the compiled JSON code after the :meth:`compile()` has been called.

      :returns: The compiled JSON code or ``{}``, if :meth:`compile()` has not previously been called.
      :rtype: dict


   .. py:method:: accept(visitor: Visitor) -> dict
      :abstractmethod:


      Provide abstract interface for cross-compilation from SQL to JSON.

      :param visitor: The visitor object performing the cross-compilation (see :class:`SqlToJsonVisitor`.)
      :type visitor: Visitor

      :returns: The cross-compiled JSON code as dictionary.
      :rtype: dict



   .. py:method:: compile() -> None
      :abstractmethod:


      Compile the node to an executable JSON object.

      Subclasses use this method to create the dictionary representing the operation.
      The following example shows the generated JSON code for the SQL statement ``CREATE TABLE``:

      .. code-block:: json

          {
              "endpoint": "databases",
              "request": "create",
              "payload": {
                  "title": [
                      {
                          "type": "text",
                          "text": {"content": "students"}
                      }
                  ],
                  "properties": {
                      "studentid": {"number": {}},
                      "name": {"title": {}},
                      "grade": {"rich_text": {}}
                  }
              }
          }




.. py:class:: Visitor(table_catalog: Optional[MetaData] = None)

   .. py:attribute:: _table_catalog
      :value: None



   .. py:method:: visit(node: SqlNode) -> dict


   .. py:method:: visit_ColumnDef(node: ColumnDef) -> dict
      :abstractmethod:



   .. py:method:: visit_CreateTable(node: CreateTable) -> dict
      :abstractmethod:



   .. py:method:: visit_InsertStatement(node: InsertStatement) -> dict
      :abstractmethod:



.. py:class:: MetaData

   Provide a repository to store table metadata.

   This class represents a table catalog where all table-related metadata are stored.
   It provides a dictionary-like interface to check existence and access stored metadata.


   .. py:attribute:: tables
      :type:  Dict[str, CreateTable]


   .. py:method:: add(table: CreateTable) -> None


   .. py:method:: __contains__(table_ident: Union[CreateTable, str]) -> bool


   .. py:method:: __getitem__(tablename: str) -> CreateTable


.. py:class:: ColumnDef(name: str, type: str)

   Bases: :py:obj:`SqlNode`


   Provide the AST node for SQL constructs like ``studentid int`` as table column.


   .. py:attribute:: name


   .. py:attribute:: type


   .. py:method:: compile() -> None

      Compile the node to an executable JSON object.

      Subclasses use this method to create the dictionary representing the operation.
      The following example shows the generated JSON code for the SQL statement ``CREATE TABLE``:

      .. code-block:: json

          {
              "endpoint": "databases",
              "request": "create",
              "payload": {
                  "title": [
                      {
                          "type": "text",
                          "text": {"content": "students"}
                      }
                  ],
                  "properties": {
                      "studentid": {"number": {}},
                      "name": {"title": {}},
                      "grade": {"rich_text": {}}
                  }
              }
          }




   .. py:method:: __eq__(value: SqlNode) -> bool


   .. py:method:: __repr__() -> str


   .. py:method:: accept(visitor) -> dict

      Provide abstract interface for cross-compilation from SQL to JSON.

      :param visitor: The visitor object performing the cross-compilation (see :class:`SqlToJsonVisitor`.)
      :type visitor: Visitor

      :returns: The cross-compiled JSON code as dictionary.
      :rtype: dict



.. py:class:: CreateTable(table_name: str, columns: List[ColumnDef])

   Bases: :py:obj:`SqlNode`


   Provide the AST node for the SQL construct ``CREATE TABLE``.


   .. py:attribute:: table_name


   .. py:attribute:: columns


   .. py:method:: compile()

      Compile the node to an executable JSON object.

      Subclasses use this method to create the dictionary representing the operation.
      The following example shows the generated JSON code for the SQL statement ``CREATE TABLE``:

      .. code-block:: json

          {
              "endpoint": "databases",
              "request": "create",
              "payload": {
                  "title": [
                      {
                          "type": "text",
                          "text": {"content": "students"}
                      }
                  ],
                  "properties": {
                      "studentid": {"number": {}},
                      "name": {"title": {}},
                      "grade": {"rich_text": {}}
                  }
              }
          }




   .. py:method:: accept(visitor: Visitor) -> dict

      Provide abstract interface for cross-compilation from SQL to JSON.

      :param visitor: The visitor object performing the cross-compilation (see :class:`SqlToJsonVisitor`.)
      :type visitor: Visitor

      :returns: The cross-compiled JSON code as dictionary.
      :rtype: dict



.. py:class:: InsertStatement(table_name: str, columns: List[str], values: List[Union[int, str]])

   Bases: :py:obj:`SqlNode`


   Base class for an AST node.


   .. py:attribute:: table_name


   .. py:attribute:: columns


   .. py:attribute:: values


   .. py:method:: accept(visitor) -> dict

      Provide abstract interface for cross-compilation from SQL to JSON.

      :param visitor: The visitor object performing the cross-compilation (see :class:`SqlToJsonVisitor`.)
      :type visitor: Visitor

      :returns: The cross-compiled JSON code as dictionary.
      :rtype: dict



.. py:class:: Parser(tokens: Iterator[Token])

   Create an SQL AST for a given SQL construct.


   .. py:attribute:: tokens

      The tokenized string as returned by :func:`tokenize()`.


   .. py:attribute:: current

      The current token being parsed.


   .. py:method:: eat(expected_type, expected_value=None)


   .. py:method:: parse()


   .. py:method:: parse_create_table() -> CreateTable


   .. py:method:: parse_insert() -> InsertStatement


.. py:class:: SqlToJsonVisitor(table_catalog=None)

   Bases: :py:obj:`Visitor`


   .. py:method:: visit_CreateTable(node: CreateTable) -> dict


   .. py:method:: visit_ColumnDef(node: ColumnDef) -> dict


   .. py:method:: visit_InsertStatement(node: InsertStatement) -> dict


.. py:function:: text(sqlcode: str) -> SqlNode

   Construct a new :class:`SqlNode` node from a textual SQL string directly.

   The main benefits of the :func:`text()` are support for bind parameters, and
   result-column typing behavior.
   The :func:`text()` enables the simplified SQL code execution as follows, as shown by the
   following example::

       >>> from normlite.sql import text
       >>> result = connection.execute(text("SELECT * FROM students"))

   Bind parameters are specified by name (named parameter style).
   Example::

       >>> from normlite.sql import text
       >>> t = text("SELECT * FROM students WHERE studentid=:studentid")
       >>> result = connection.execute(t, {"studentid": 1234})

   .. note:: :func:`text()` was inspired by the brilliant homonymous SqlAlchemy construct `text() <https://docs.sqlalchemy.org/en/20/core/sqlelement.html#sqlalchemy.sql.expression.text>`_.

   :param sqlcode: The string representing an SQL statement.
   :type sqlcode: str

   :returns: The constructed node.
   :rtype: SqlNode


